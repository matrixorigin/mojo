%%
\documentclass[sigconf,nonacm]{acmart} % nonacm removes the ACM reference format
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{svg}
%% \usepackage{blindtext}

% Copyright
\renewcommand\footnotetextcopyrightpermission[1]{} % removes footnote with conference info
\setcopyright{none}
\settopmatter{printacmref=false}
\pagestyle{plain} % removes running headers

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Version Control Systewm For Data With MatrixOne}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Hongshen Gou}
\email{gouhongsheng@matrixorigin.cn}
\affiliation{
  \institution{MatrixOrigin}
  \city{Shanghai}
  \country{China}
}

\author{Feng Tian}
\email{tianfeng@matrixorigin.io}
\affiliation{
  \institution{MatrixOrigin}
  \city{San Jose}
  \country{USA}
}

\author{Long Wang}
\email{wanglong@matrixorigin.cn}
\affiliation{
  \institution{MatrixOrigin}
  \city{Shenzhen}
  \country{China}
}

\author{Peng Xu}
\email{xupeng@matrixorigin.cn}
\affiliation{
  \institution{MatrixOrigin}
  \city{Shanghai}
  \country{China}
}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
We have developed a relational database system called MatrixOne, which has 
a powerful snapshot system.  User can perform git-like operations on 
large amount of data almost instantly, thus bring the power of version 
control to data-engineering in the same way as git to software engineering.
Data engineers can perform branch, diff, merge, revert, etc on terabytes of data 
without fear of losing data or causing data corruptions.
\end{abstract}

\maketitle

\section{Introduction}
Artificial Intelligence (AI), especially technologies such as deep learning 
and large language model (LLM) is experiencing a period of explosive 
growth.  Many experts consider data as the fuel that powers the AI revolution.
Every step of building a great AI system, from pre-train to prompting, all 
depends on large amount of high quality data.

The ever increasing importance of data to AI systems has given rise to the
field of data engineering.   A significant amount of AI development is actually
data processing and feature engineering.   The result is that data for AI is much 
more dynamic.  People does not only analyzing static data, but also need to clean
and modify data, to label data (either by human or by LLM), and to manage labels.
A software project is not only building code, but more and more becoming a data project.

Version control system (VCS) is among the most important tools in a software 
engineer's daily work.  Its history dates back to earliest days of software
engineering.  Git \cite{Git} and git services such as GitHub has become the standard
tool for software engineers to manage their code.   However, for data engineers,
there is little help.  Manage large amount of data using for example git is slow
and tools such as diff/merge in general do not work well.  People often choose 
to store data in file system or in object stores such as S3, but modifying many 
large files is difficult, slow, and error prone.

MatrixOrigin has developped a relational database system called MatrixOne. 
It has a powerful and efficient snapshot system that enables version control
for large amount of data.  If we consider a database as git repository and 
table as a file in git, we can support all day to day git operations such as
clone/branch, push/pull, diff, merge, revert, on terabytes of data almost 
instantly.

In the rest of this paper, we will introduce the version control operations
supported by MatrixOne.  We explain the semantics of these operations and 
walk through a typical day to day usage of MatrixOne to work with data version 
control.  Next we will discuss the implementation of snapshot system in 
MatrixOne, followed by the implementation of some of the version control 
operations like diff/merge.  Finally, we will explore some of the 
future directions.

\section{Version Control Operations}\label{sec:vcop}
Let's consider table \texttt{T(a int, b varchar, c json)} in a database.  
We can refer to a snapshot of \texttt{T} at timestamp
ts as \texttt{T\{mo\_ts = ts\}}.  For example, user can read a table at a specific
timestamp using 
\begin{verbatim}
  SELECT * FROM T{mo_ts='2025-09-12 12:34:56'}
\end{verbatim}
MatrixOne supports PITR (Point In Time Recovery) and by default, user can refer
to a snapshot of a table within 24 hours.  User can also create a named snapshot
for a table using 
\begin{verbatim}
  CREATE SNAPSHOT snapshot1 FOR TABLE T
\end{verbatim}  
and refer to it using \texttt{T\{snapshot = 'sn1'\}}.  
Viewed from version control perspective, a named snapshot corresponds to a git tag.
A table without a timestamp or named snapshot specified refers to the table
at current timestamp.
User can also take a snapshot of a database, which is the collection of snapshots 
of all tables in the database.  Later in this paper we will only discuss 
snapshot of a table.

User can clone a table from a snapshot using 
\begin{verbatim}
  CREATE TABLE TClone FROM SNAPSHOT T{snapshot='sn1'}
\end{verbatim}
Cloning a table roughly corresponds to cloning a git repository or
creating a new branch from a git tag.  Once cloned, T and TClone are 
separate tables and insert, delete, update to T and TClone are 
independent.  Now let's assume after creating TClone, user modified data
in both tables and created new snapshot \texttt{sn2} on T and snapshot \texttt{sn3} on TClone. 
\begin{verbatim}
  T:             --> sn1 --> sn2 --> 
                      |
  TClone:             |----> sn3 --> 
\end{verbatim}
We say that \texttt{T\{snapshot='sn2'\}} and \texttt{TClone\{snapshot='sn3'\}} 
share a common base revision \texttt{T\{snapshot='sn1'\}}.

Like git, user can push/pull changes from one table to another by 
restoring a snapshot.  For example, user can pull the more recent 
changes in sn2 from T to TClone using \begin{verbatim}
  RESTORE TABLE TClone FROM
        SNAPSHOT T{snapshot='sn2'}
\end{verbatim}
Restore will overwrite all modifications in TClone and completely replace 
data of TClone with \texttt{T\{snapshot='sn2'\}}.  It is equivalent to 
\texttt{git reset --hard sn2}.

User can diff two snapshots using 
\begin{verbatim}
  SNAPSHOT DIFF T{snapshot='sn1'} 
         AND TClone{snapshot='snX'}
\end{verbatim}  
Logically, \texttt{SNAPSHOT DIFF} returns the result of the following SQL query:
\begin{verbatim}
  WITH UnionT as (
    SELECT -1 as cnt, a, b, c FROM T{snapshot='sn1'}
    UNION ALL
    SELECT 1 as cnt, a, b, c FROM TClone{snapshot='sn3'}
  )
  SELECT sum(cnt) as diffCnt, a, b, c FROM UnionT 
  GROUP BY a, b, c
  HAVING sum(cnt) <> 0
\end{verbatim}
Each row in the result of \texttt{SNAPSHOT DIFF} represents a potential conflict.
\texttt{SNAPSHOT DIFF} does not require the two snapshots are branched from a 
common base revision as long as they have the same schema (same column names and types and primary key), 
however, later in the paper we will see that diff between 
two snapshots that share a commmon base revision can be efficiently 
implemented in MatrixOne.  

User can perform 3-way merge of merging \texttt{TClone} into \texttt{T}
using \texttt{T\{snapshot='sn1'\}} as the base revision. 
\begin{verbatim}
  SNAPSHOT MERGE TABLE T FROM TClone 
    [BASED ON T{snapshot='sn1'}]
    [WHEN CONFLICT FAIL|SKIP|ACCEPT]
\end{verbatim}
The \texttt{BASED ON} clause is optional and if not specified, MatrixOne will try to 
compute an implicit base revision.  Merge is different from restoring a snapshot in 
that merge will resolve conflicts found in the result of \texttt{SNAPSHOT DIFF}.
MatrixOne supports three modes to handle conflicts: \texttt{FAIL}, \texttt{SKIP}, 
and \texttt{ACCEPT}.  \texttt{FAIL} means that merge will fail if conflicts are found
and user must resolve all the conflicts manually.  \texttt{SKIP} means that merge will 
resolve the conflicts by accepting the version in \texttt{T} and \texttt{ACCEPT} will 
accept the version in \texttt{TClone}.  Version of data in \texttt{T} and \texttt{TClone}
are computed differently depending on whether \texttt{T} and \texttt{TClone} have primary key.
First let's consider the case when \texttt{T} has a primary key \texttt{a} and the diff has
found a conflict on row identified by \texttt{a\_value}.  Consider the following cases:
\begin{enumerate}
\item \texttt{a\_value} does not exist in the common base revision 
and \texttt{a\_value} does not exist in \texttt{TClone}.
This means that only \texttt{T} has inserted the row with \texttt{a\_value} 
after branching from the common base revision.  This is a false conflict and 
merge will keep the row in \texttt{T}.

\item \texttt{a\_value} does not exist in the common base revision 
and \texttt{a\_value} does not exist in \texttt{T}.
This means that only \texttt{TClone} has inserted the row with \texttt{a\_value} 
after branching from the common base revision.  This is a false conflict and 
merge will keep the row in \texttt{TClone}.

\item \texttt{a\_value} does not exist in the common base revision and 
\texttt{a\_value} exists in both \texttt{T} and \texttt{TClone}.  
This means both \texttt{T} and \texttt{TClone} have inserted the row 
with \texttt{a\_value} but with different values.  \texttt{SKIP} will 
use the version in \texttt{T}, and \texttt{ACCEPT} will use the 
version in \texttt{TClone}, and \texttt{FAIL} will fail the merge.

\item \texttt{a\_value} exists in the common base revision and has not been deleted or updated
in \texttt{T}. This means only \texttt{TClone} has deleted or updated 
this row.  This is a false conflict and merge will perform the 
same operation as \texttt{TClone}.

\item \texttt{a\_value} exists in the common base revision and has not been deleted or updated
in \texttt{TClone}. This means only \texttt{T} has deleted or updated 
this row.  This is a false conflict and merge will perform the 
same operation as \texttt{T}.

\item \texttt{a\_value} exists in the common base revision and has been deleted or updated
in both \texttt{T} and \texttt{TClone}.  This is a true conflict and 
\texttt{SKIP} will use the version (which could be a deleted row) in \texttt{T} 
and \texttt{ACCEPT} will use the version in \texttt{TClone}.  \texttt{FAIL} 
will fail the merge.
\end{enumerate}
When \texttt{T} has no primary key, for each row that is found by \texttt{SNAPSHOT DIFF}, 
there may be multiple rows with same values in all columns in the common base revision, \texttt{T},
and \texttt{TClone}.  We use $N_0$, $N_T$, and $N_{TClone}$ to denote the number of such rows 
in the common base revision, \texttt{T}, \texttt{T}, and \texttt{TClone} respectively.

Let $\delta_T = N_T - N_0$ and $\delta_{TClone} = N_{TClone} - N_0$, we consider the following cases:
\begin{enumerate}
\item $\delta_T = 0$, this is a false conflit and 
merge keep $N_{TClone}$ such rows in the merge result.
\item $\delta_{TClone} = 0$, this is a false conflict and 
merge keep $N_{TClone}$ such rows in the merge result.
\item $\delta_T \neq 0$ and $\delta_{TClone} \neq 0$, in this case, \texttt{SKIP}
will keep $N_T$ rows, \texttt{ACCEPT} will keep $N_{TClone}$ rows, and 
\texttt{FAIL} will fail the merge.
\end{enumerate}

\section{Snapshot system of MatrixOne}

Data version control is implemented using snapshot system in MatrixOne.
To understand how snapshot system works, we need first to explain 
the storage and transaction management system of MatrixOne.  MatrixOne 
is a cloud native, distributed, database system that supports both transactional
and analytical workloads (HTAP).  A MatrixOne database system has three 
kind of nodes, 
\begin{description}
\item[LogService] forms a Raft group and is responsible for the storing the write ahead log (WAL) 
of the database system.  A MatrixOne database system usually has 3 to 5 LogService nodes.
\item[TN] is the transaction decision node which decides if a transaction can commit and 
seqences transaction logs.  TN node is stateless and can be recovered in seconds.  A MatrixOne 
database system usually has only one TN node but if necessary, TN can failover to a hot standby. 
\item[CN] is the compute nodes that executes queries.  A MatrixOne database can have unlimited
number of CN nodes.
\end{description}
\begin{figure}[h]
  \centering
  \includegraphics[width=\linewidth]{m1a}
  \caption{The Architcture of MatrixOne Database}
  \Description{MatrixOne Database Architecture}
\end{figure}

MatrixOne stores table in objects of an object storage system such as S3.  
Each object contains a few row groups and each row group uses column store format to store 
the data.  Objects of a table forms a LSM tree, ordered by the primary keys 
or clustering keys with an uniquifier.  
Once written to object storage, the data is immutable.  
To delete a row, a tombstone record that 
contains the primary key (or clustering key plus uniquifier) and the physical rowid of 
deleted row is written to a separate object.
A directory structure stores the metadata of objects of a table.  At any timestamp, this
directory structure corresponds to a snapshot of the table.

A transaction begins execution in a CN node.  The transaction sees a consistent snapshot
of the database and stores all modifications in its own workspace.  When the data in the
workpsace grows beyond a threshold, the transaction writes the data to object storage
and only stores the metadata of the written objects in the workspace.  When it is time to 
commit the transaction, CN write the workspace to DN.  DN commits the transaction by 
writing WAL to LogService.  If the transaction only modifies a few rows, DN will write the 
modifications to an in memory object without writing object storage.  Rows in the in-memory
object have a timestamp and DN can only append, but not modify rows in the in-memory 
object.  When enough rows are accumulated or a certain time has passed, DN will close 
this in memory object and write it to the object storage.  

From the above description we can see that a snapshot of a table is simply the directory 
structure of metadata of all objects (both DN in memory objects and on storage objects)
of the table.  Reading of a timestamp-based snapshot is implemented by simply filtering 
objects using the timestamp stored in metadata of objects.  For a named snapshot, MatrixOne
force a flush of the in memory objects of the table.  The sysmem stores the directory 
structure of metadata of objects and does necessary bookkeeping to associate the name 
of the snapshot with the directory structure.

Like a typical log-structured storage system, there may be a compaction
or garbage collection process to compact objects.  The garbage collection process
understands the snapshot system and will not delete objects that are referenced 
by a snapshot.

\section{Version Control Operations}
With the snapshot system in MatrixOne, cloning and restoring a table is relatively 
easy. Clone a table from a snapshot (maybe of another table) is implemented by copying 
the directory structure of metadata of the snapshot. Restoring a table from a 
snapshotis simply setting current state of the table to the snapshot.

Consider table \texttt{T} and a cloned table \texttt{TClone} that share a 
common base revision \texttt{sn1}.  After creating \texttt{TClone}, user modified 
data in both \texttt{T} and \texttt{TClone} and the two tables have progressed 
independently to different snapshots \texttt{sn2} and \texttt{sn3}.  We use 
$\Delta_{sn2}$ to denote the set of objects that in \texttt{sn2} but not in \texttt{sn1}
and similarly, $\Delta_{sn3}$ to denote the set of objects that in \texttt{sn3} but 
not in \texttt{sn1}.

\subsection{Diff}
To find \texttt{SNAPSHOT DIFF} result of \texttt{sn2} and \texttt{sn3}, we only need to
read the objects in $\Delta_{sn2}$ and $\Delta_{sn3}$.  
If table \texttt{T} has a primary key \texttt{a},
all operations on one primary key in $\Delta_{sn2}$ can be collapsed into one logical operation; 
a delete , an insert or an update (physically two operations, a delete followed by an insert).
Note that in this case, the deletion is always performed on a row in the common base revision.
This collapsing is the same as applying tombstone in 
an ordinary table scan on the LSM tree except that we need to output the deletion of a 
row in the common base revision.  Note that we need to give a different sign (+/-) to 
the \texttt{cnt} of each row depending on whether it is deleted, or inserted. 
We perform the same scanning and collapsing operation on $\Delta_{sn3}$.  
Next we perform a special join to find the differences of the two multi-sets.
Newly inserted or updated rows that have the same values in all columns, and
deletions on the same row in the common base revision should be cancelled.  
If there are deletions left in the join result, we perform a lookup (another join with
common base revision) to find out the values of all columns.
If table \texttt{T} has no primary key, we perform the same join to cancel out 
inserted or updated rows with the same values in all columns and deletions on the same 
physical row (the tombstone contains uniquifier and physical rowid) in the common 
base revision.  We find out values of all columns of deleted rows using physical rowid. 
A hash aggregation is then used to find out the \texttt{diffCnt} of each row.
\subsection{Three Way Merge}
Three way merge from \texttt{TClone} to \texttt{T} is implemented by first 
performing the join described in the \texttt{SNAPSHOT DIFF} operation.  
Note that scanning and collapsing operations described above actually
carries more information than the \texttt{diffCnt} in the result of \texttt{SNAPSHOT DIFF}.
We know that a plus one \texttt{diffCnt} whether it comes from a deletion from $\Delta_{sn2}$
or from an insert from $\Delta_{sn3}$.  
In the case that \texttt{T} has a primary key, we can use this extra information to tell
whether a conflict is 
a false conflict 
(the primary key appears in only one of $\Delta_{sn2}$ and $\Delta_{sn3}$)
or a true conflict 
(if the primary key appears in both both $\Delta_{sn2}$ and $\Delta_{sn3}$)
.  There is an rare, but interesting case that when one side updated a row 
in the common base revision to a row with same values in all columns, 
that is, the row is simply "moved" to a different position.  We do not 
consider this "move" as a change of data therefore we treat this as a 
false conflict.  This is the only case that merge will need to read out
the full deleted row from the common base revision.

The same can be said for the case that \texttt{T} has no primary key.
A conflict is a true conflict only if a row with same values in all columns
appear in both $\Delta_{sn2}$ and $\Delta_{sn3}$.  In this case, merge will 
need to read out the full deleted row from the common base revision using 
physical rowid.  Merge will then resolve rows of true conflict as described
in section \ref{sec:vcop}.

\subsection{Compact and Garbage Collection}
MatrixOne will not compact (therefore, will not garbage collect) objects that 
are referenced by a named snapshot.  However, it is possible for the system to
schedule a compacting/GC job on \texttt{T} between \texttt{sn1} and \texttt{sn2}, 
or on \texttt{TClone} between \texttt{sn1} and \texttt{sn3}.  MatrixOne performs
compaction as a transaction of deleting objects and writing new objects, that is,
move all valid rows from several old objects to one or more new objects.  
User typically branch from a well organized snapshot so that compaction of objects
in the common base revision is rare.  Usually user will merge the result back to the 
main branch after some data engineering work, and our merge algorithm will remove 
all those "moved" rows by compaction early on before considering them for conflict 
resolution.   

\subsection{Two Way Merge}
In most cases MatrixOne does proper bookkeeping of snapshots and clones so that 
the system may be able to know the common base revision of \texttt{T} 
and \texttt{TClone}.  A two way merge is actually implemented by a three way 
merge with an implicit common base revision.

Sometimes the system may not be able to know the commmon base revision or 
the common base revision is not available.  For example, two tables are clones 
from the same original table and user deleted the original table and 
all its snapshots.  In this case the two way merge is computed as a three way
merge with an empty common base revision.  Even in this case, if most of the 
data in the two tables share a commmon base revision, diff and merge 
can be computed much more efficiently than using the SQL query of 
section \ref{sec:vcop} by simply observing that rows in the shared objects 
of the two tables will cancel each other out.

\subsection{Discussion}
We discuss some interesting issues and possible future works related to 
the implementation of version control operations of MatrixOne.

\subsubsection{Three Way Diff}
MaxtrixOne only supports two way diff at this moment.  Three way diff can
be implemented efficiently as well by skipping shared objects in common 
base revision.
While three way diff is important to decide the "false" conflicts, we believe end 
user will be more interested in the two way diff result.  Three way 
comparision is much more useful when we perform merge.  Thus we decided
not to expose three way diff to reduce operation complexity and confusion.

\subsubsection{Revision Lineage}
MatrixOne keeps track of the revision lineage of two tables that are one 
branch away from each other.  When a two way merge cannot find a common 
base revision, an empty common base revision is used.  MatrixOne can 
still optimize the merge by skipping shared objects.  This is differnt 
from a three way merge that user explicitly specifies the common base revision.
Without a common base revision, MatrixOne cannot tell whehter a row is newly 
inserted or, updated -- especially, it cannot tell if the row is simply "moved".
To be safe, MatrixOne can only treat this as a true conflict and ask 
user to decide how to resolve.

\subsubsection{Conflict Resolution}

\subsubsection{Indices}

\section{Experimental Results}
We performed a series of experiments to evaluate the performance of 
our version control operations.  We used the TPCH 1TB dataset on one 
c6gd.16xlarge (64 arm cores, 128GB memory) instance on AWS and tables 
are stored in S3.  We load the lineitem table twice into two tables 
\texttt{L1} and \texttt{T2}.  WE created a clone \texttt{L1Clone} 
from \texttt{L1}, and performed some modifications to 1000 rows in 
\texttt{L1Clone}, and later measured the time taken by diff and merge.

The experiments were performed twice, first without primary key and
then with primary key \texttt{(l\_orderkey, l\_linenumber).}

TODO: really do the work.

\section{Conclusion}

%% \begin{table}
%%   \caption{Frequency of Special Characters}
%%   \label{tab:freq}
%%   \begin{tabular}{ccl}
%%     \toprule
%%     Non-English or Math&Frequency&Comments\\
%%     \midrule
%%     \O & 1 in 1,000& For Swedish names\\
%%     $\pi$ & 1 in 5& Common in math\\
%%     \$ & 4 in 5 & Used in business\\
%%     $\Psi^2_1$ & 1 in 40,000& Unexplained usage\\
%%   \bottomrule
%% \end{tabular}
%% \end{table}
%% 
%% To set a wider table, which takes up the whole width of the page's
%% live area, use the environment \textbf{table*} to enclose the table's
%% contents and the table caption.  As with a single-column table, this
%% wide table will ``float'' to a location deemed more
%% desirable. Immediately following this sentence is the point at which
%% Table~\ref{tab:commands} is included in the input file; again, it is
%% instructive to compare the placement of the table here with the table
%% in the printed output of this document.
%% 
%% %% \begin{table*}
%% %%   \caption{Some Typical Commands}
%%   \label{tab:commands}
%%   \begin{tabular}{ccl}
%%     \toprule
%%     Command &A Number & Comments\\
%%     \midrule
%%     \texttt{{\char'134}author} & 100& Author \\
%%     \texttt{{\char'134}table}& 300 & For tables\\
%%     \texttt{{\char'134}table*}& 400& For wider tables\\
%%     \bottomrule
%%   \end{tabular}
%% \end{table*}

%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.
%% \begin{acks}
%% To Robert, for the bagels and explaining CMYK and color spaces.
%% \end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
%%\bibliographystyle{ACM-Reference-Format}
%%\bibliography{sample-base}


%%
%% If your work has an appendix, this is the place to put it.
%% \appendix

\renewcommand\bibname{References}
\bibliographystyle{abbrv}
\bibliography{ref}

\end{document}
\endinput
%%
%% End of file `sample-sigplan.tex'.
